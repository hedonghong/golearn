
1.什么Mysql的事务？事务的四大特性？事务带来的什么问题？

Mysql中事务的隔离级别分为四大等级：读未提交（READ UNCOMMITTED）、读提交 （READ COMMITTED）、可重复读 （REPEATABLE READ）、串行化 （SERIALIZABLE）。

在Mysql中事务的四大特性主要包含：原子性（Atomicity）、一致性（Consistent）、隔离性（Isalotion）、持久性(Durable)，简称为ACID。

原子性：是指事务的原子性操作，对数据的修改要么全部执行成功，要么全部失败，实现事务的原子性，是基于日志的Redo/Undo机制。
一致性：是指执行事务前后的状态要一致，可以理解为数据一致性。
隔离性：侧重指事务之间相互隔离，不受影响，这个与事务设置的隔离级别有密切的关系。
持久性：则是指在一个事务提交后，这个事务的状态会被持久化到数据库中，也就是事务提交，对数据的新增、更新将会持久化到数据库中。
在我的理解中：原子性、隔离性、持久性都是为了保障一致性而存在的，一致性也是最终的目的。

没有那种隔离级别是完美的，只能根据自己的项目业务场景去评估选择最适合的隔离级别，大部分的公司一般选择Mysql默认的隔离级别：可重复读。

隔离级别从：读未提交-读提交-可重复读-串行化，级别越来越高，隔离也就越来越严实，到最后的串行化，当出现读写锁冲突的时候，后面的事务只能等前面的事务完成后才能继续访问。

读未提交：读取到别的事务还没有提交的数据，从而产生了脏读。
读提交：读取别的事务已经提交的数据，从而产生不可重复读。
可重复读：事务开启过程中看到的数据和事务刚开始看到的数据是一样的，从而产生幻读，在Mysql的中通过MVCC多版本控制的一致性视图解决了不可重复读问题以及通过间隙锁解决了幻读问题。
串行化：对于同一行记录，若是读写锁发生冲突，后面访问的事务只能等前面的事务执行完才能继续访问。
举个例子，假如有一个user表，里面有两个字段id和age，里面有一条测试数据：（1,24），现在要执行age+1，同时有两个事务执行：


|事务1|事务2|
| ----------- | ----------- |
|启动事务，接着查询age（a1）|-|
|-|启动事务|
|-|查询age（a2）|
|-|执行age=age+1|
|查询age（a3）|-|
|-|提交事务|
|查询age（a4）|-|
|提交事务|-|
|查询age（a5）|-|
经过上面的执行，在四种隔离级别下a1,a2,a3,a4,a5的值分别是多少？我们来认真的分析一波：

读未提交：a1和a2因为读的是初始值所以为24，隔离级别为读未提交，事务2执行了age=age+1，不管事务2是否提交，那么a3、a4和a5的值都是25。
读提交：a1和a2因为读的是初始值所以为24，隔离级别为读提交所以a3还是24，a4和a5因为事务2已经提交所以得到的值是25。
可重复读：a1和a2因为读的是初始值所以为24，可重复读的隔离级别下，a3和a4读取的值和事务开始的结果一样，所以还是24，a5前一步因为已经提交事务，所以a5的值是25。
串行化：a1和a2因为读的是初始值所以为24，串行化隔离级别下，当事务2修改数据的时候，获取了写锁，事务1读取age的值会被锁住，所以在事务1的角度下a3和a4读取的值为24，a5的值为25。
当你能够分析得出这个例子下，在不同隔离级别下分析的出a1-a5的值，说明你对事务的隔离级别已经有比较深入的理解了。


2.你详细了解过MVCC吗？它是怎么工作的？

MVCC叫做多版本控制，实现MVCC时用到了一致性视图，用于支持读提交和可重复读的实现。

对于一行数据若是想实现可重复读取或者能够读取数据的另一个事务未提交前的原始值，那么必须对原始数据进行保存或者对更新操作进行保存，这样才能够查询到原始值。

在Mysql的MVCC中规定每一行数据都有多个不同的版本，一个事务更新操作完后就生成一个新的版本，并不是对全部数据的全量备份，因为全量备份的代价太大了：

开始 v1:
k1=10
row trx-id=10
^
|
u1
|
v2:
set k = k+1
transaction id = 15

k1=11
row trx-id=15

^
|
u2
|
v3:

set k = k+2
transaction id = 20

k1=13
row trx-id=20

如图中所示，假如三个事务更新了同一行数据，那么就会有对应的v1、v2、v3三个数据版本，每一个事务在开始的时候都获得一个唯一的事务id（transaction id），并且是顺序递增的，并且这个事务id最后会赋值给row trx_id，这样就形成了一个唯一的一行数据版本。

实际上版本1、版本2并非实际物理存在的，而图中的U1和U2实际就是undo log日志（回滚日志），这v1和v2版本是根据当前v3和undo log计算出来的。

InnoDB引擎就是利用每行数据有多个版本的特性，实现了秒级创建“快照”，并不需要花费大量的是时间。

3.Mysql的InnoDB和MyISAM有什么区别？

（1）InnoDB和MyISAM都是Mysql的存储引擎，现在MyISAM也逐渐被InnoDB给替代，主要因为InnoDB支持事务和行级锁，MyISAM不支持事务和行级锁，MyISAM最小锁单位是表级。因为MyISAM不支持行级锁，所以在并发处理能力上InnoDB会比MyISAM好。

（2） 数据的存储上：MyISAM的索引也是由B+树构成，但是树的叶子结点存的是行数据的地址，查找时需要找到叶子结点的地址，再根据叶子结点地址查找数据。
    InnoDB的主键索引的叶子结点直接就是存储行数据，查找主键索引树就能获得数据：
    若是根据非主键索引查找，非主键索引的叶子结点存储的就是，当前索引值以及对应的主键的值，若是联合索引存储的就是联合索引值和对应的主键值。

3）数据文件构成：MyISAM有三种存储文件分别是扩展名为：.frm（文件存储表定义）、.MYD (MYData数据文件)、.MYI (MYIndex索引文件)。而InnoDB的表只受限于操作系统文件的大小，一般是2GB

（4）查询区别：对于读多写少的业务场景，MyISAM会更加适合，而对于update和insert比较多的场景InnoDB会比较适合。

（5）count()区别：select count() from table，MyISAM引擎会查询已经保存好的行数，这是不加where的条件下，而InnoDB需要全表扫描一遍，InnoDB并没有保存表的具体行数。

（6）其它的区别：InnoDB支持外键，但是不支持全文索引，而MyISAM不支持外键，支持全文索引，InnoDB的主键的范围比MyISAM的大。

4.你知道执行一条查询语句的流程吗？